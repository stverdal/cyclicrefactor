# Refactor Planning Prompt
# Phase 1 of sequential file mode - creates a detailed plan for breaking the cycle

You are an expert software engineer. Analyze this cyclic dependency and create a detailed refactoring plan.

## Cycle Information
- ID: {id}
- Dependency graph: {graph}
- Files: {files}

## Problem Description
{description}

## Source Code Overview
{file_snippets}

---

## EXAMPLE PLAN

### Example Input:
Cycle: ReportGenerator.cs → DataService.cs → ReportGenerator.cs
- ReportGenerator imports DataService for FetchData()
- DataService imports ReportGenerator for FormatOutput()

### Example Output:
```json
{
  "strategy": "interface_extraction",
  "summary": "Extract IOutputFormatter interface from ReportGenerator. DataService depends on interface, ReportGenerator implements it.",
  "new_files": [
    {
      "path": "Interfaces/IOutputFormatter.cs",
      "purpose": "Interface for output formatting",
      "content_description": "Interface with FormatOutput(string data) method returning formatted string"
    }
  ],
  "file_changes": [
    {
      "path": "ReportGenerator.cs",
      "order": 1,
      "changes": [
        "Add 'using MyApp.Interfaces;'",
        "Add ': IOutputFormatter' to class declaration",
        "No other changes needed - method signature already matches"
      ],
      "imports_to_add": ["using MyApp.Interfaces;"],
      "imports_to_remove": [],
      "reason": "ReportGenerator implements the new interface"
    },
    {
      "path": "DataService.cs",
      "order": 2,
      "changes": [
        "Remove 'using MyApp.Reports;'",
        "Add 'using MyApp.Interfaces;'",
        "Change constructor parameter from ReportGenerator to IOutputFormatter",
        "Change field type from ReportGenerator to IOutputFormatter"
      ],
      "imports_to_remove": ["using MyApp.Reports;"],
      "imports_to_add": ["using MyApp.Interfaces;"],
      "reason": "DataService now depends on abstraction, breaking the cycle"
    }
  ],
  "execution_order": ["Interfaces/IOutputFormatter.cs", "ReportGenerator.cs", "DataService.cs"],
  "notes": "Interface file must be created first so other files can import it"
}
```

---

## Your Task: Create a Refactoring Plan

### REASONING STEPS (Complete each before outputting)

**STEP 1: Map the Dependencies**
Look at Source Code. For each file, list:
- What does it import from cycle members?
- What methods/types does it use from those imports?

**STEP 2: Find the Weakest Link**
Which dependency is easiest to break? Consider:
- Fewer methods used = easier to abstract
- Utility-like usage = good candidate for parameter injection
- Type-heavy usage = needs interface extraction

**STEP 3: Design the Abstraction**
If creating interface/abstraction:
- What methods must it include?
- What namespace should it be in?
- Which file implements it, which depends on it?

**STEP 4: Order the Changes**
New files must be created BEFORE files that import them.
Implementation must come BEFORE usage.

---

## Output Format (JSON)

```json
{
  "strategy": "<interface_extraction|dependency_inversion|shared_module>",
  "summary": "<1-2 sentence summary of the approach>",
  "new_files": [
    {
      "path": "<path for new file if creating one>",
      "purpose": "<what this file contains>",
      "content_description": "<describe the interface/class to create>"
    }
  ],
  "file_changes": [
    {
      "path": "<existing file path>",
      "order": 1,
      "changes": [
        "<specific change 1: e.g., 'Remove import of ClassB'>",
        "<specific change 2: e.g., 'Add import of IClassB interface'>",
        "<specific change 3: e.g., 'Change constructor parameter from ClassB to IClassB'>"
      ],
      "imports_to_remove": ["<import statement to remove>"],
      "imports_to_add": ["<import statement to add>"],
      "reason": "<why this change helps break the cycle>"
    }
  ],
  "execution_order": ["<file1.cs>", "<file2.cs>"],
  "notes": "<any additional considerations>"
}
```

Be specific about WHAT to change. The actual code will be written in the next phase.

---

## ✓ VERIFICATION BEFORE OUTPUT

□ Every file path I reference exists in the Source Code section
□ If I'm creating an interface, I specified what methods it needs
□ My execution_order starts with new files, then implementations, then consumers
□ After all changes, the cycle-causing import can be removed

Output ONLY the JSON object.
