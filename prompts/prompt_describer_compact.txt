# Compact Describer Prompt (for low-VRAM / small context LLMs)

Analyze this cyclic dependency and recommend a fix strategy.

## Cycle: {id}
Graph: {graph}
Files: {files}

## Source Code
{file_snippets}

---

## EXAMPLE

**Input:** Cycle: ServiceA.cs → ServiceB.cs → ServiceA.cs

**Output:**
```json
{
  "text": "Bidirectional dependency. ServiceA imports ServiceB for logging, ServiceB imports ServiceA for config. Tight coupling prevents independent testing.",
  "cycle_type": "bidirectional",
  "recommended_strategy": "interface_extraction",
  "strategy_rationale": "Extract IConfigProvider interface. ServiceB depends on interface, ServiceA implements it.",
  "first_steps": ["Create IConfigProvider with GetConfig() method", "ServiceA implements IConfigProvider", "ServiceB uses IConfigProvider instead of ServiceA"]
}
```

---

## STRATEGY DECISION TREE

1. **Two files import each other?** → `interface_extraction`
2. **Chain A→B→C→A?** → `shared_module` (extract common code)
3. **Lower layer imports higher?** → `dependency_inversion`

## Output (JSON)

```json
{
  "text": "<What creates the cycle and why it's problematic>",
  "cycle_type": "<bidirectional|transitive|layer_violation>",
  "recommended_strategy": "<interface_extraction|dependency_inversion|shared_module>",
  "strategy_rationale": "<Why this strategy fits>",
  "first_steps": ["<action 1>", "<action 2>"]
}
```

## ✓ VERIFY
□ I identified specific imports creating the cycle
□ My first_steps are concrete (name the interface/file to create)

Output ONLY JSON.
