# Compact Refactor Prompt (for low-VRAM / small context LLMs)

Break the cyclic dependency using SEARCH/REPLACE patches.

## Cycle: {id}
Graph: {graph}
Files: {files}

## Description
{description}

## Strategy: {strategy}

## Source Code
{file_snippets}

---

## EXAMPLE (Interface Extraction)

**Input:** Cycle between UserService.cs and OrderService.cs
**Source:** OrderService imports UserService to call GetUserName()

**Output:**
```json
{{
  "reasoning": "Extract IUserService interface with GetUserName method. OrderService depends on interface.",
  "strategy_used": "interface_extraction",
  "new_files": [
    {{
      "path": "Interfaces/IUserService.cs",
      "content": "namespace MyApp.Interfaces\\n{{\\n    public interface IUserService\\n    {{\\n        string GetUserName(int userId);\\n    }}\\n}}"
    }}
  ],
  "changes": [
    {{
      "path": "Services/UserService.cs",
      "prepend": "using MyApp.Interfaces;",
      "search_replace": [
        {{
          "search": "namespace MyApp.Services\\n{{\\n    public class UserService",
          "replace": "namespace MyApp.Services\\n{{\\n    public class UserService : IUserService"
        }}
      ]
    }},
    {{
      "path": "Services/OrderService.cs",
      "prepend": "using MyApp.Interfaces;",
      "search_replace": [
        {{
          "search": "    private readonly UserService _userService;",
          "replace": "    private readonly IUserService _userService;"
        }}
      ]
    }}
  ]
}}
```

---

## YOUR OUTPUT (JSON)

```json
{{
  "reasoning": "<brief explanation>",
  "strategy_used": "<interface_extraction|dependency_inversion|shared_module>",
  "new_files": [
    {{"path": "Interfaces/IFoo.cs", "content": "<complete file content>"}}
  ],
  "changes": [
    {{
      "path": "path/to/existing_file",
      "search_replace": [{{"search": "<3+ lines from source>", "replace": "<new code>"}}],
      "prepend": "<NEW using statements>"
    }}
  ]
}}
```

## CRITICAL RULES

1. **SEARCH must match source EXACTLY** - Copy verbatim from Source Code above
2. **Include 3+ context lines** - Before AND after the changed code
3. **Preserve whitespace** - Exact indentation matters
4. **NEW FILES** - Use `"new_files": [{{"path": "...", "content": "..."}}]` for new interfaces/classes
5. **NEW IMPORTS** - Use `"prepend": "using ...;"` to add imports to existing files
6. **DO NOT search for non-existent text**
7. **Interface extraction MUST create interface** - Don't just rename types!

## ⚠️ AVOID THESE MISTAKES

❌ BAD: `"search": "public SensorType X"` → `"replace": "public ISensorType X"` (ISensorType doesn't exist!)
❌ BAD: Search equals Replace (no-op patch)
❌ BAD: Single line with no context

✅ GOOD: Create interface in `new_files` FIRST, then reference it in changes

## ✓ VERIFY BEFORE OUTPUT

□ Every SEARCH string exists EXACTLY in Source Code above
□ Every new type (IFoo) is created in new_files with complete content
□ Changes actually break the cycle (not just rename)

Output ONLY JSON. No commentary.
