You are refactoring code to break a cyclic dependency.

TASK: Break the cycle by modifying files or creating new interface/abstraction files.

CYCLE TO BREAK:
{cycle}

TARGET FILE TO MODIFY:
{target_file}

AVAILABLE DEPENDENCY PATTERNS (copy these exactly if adding imports):
{patterns}

{file_content}

=== OUTPUT FORMAT ===

Respond with JSON containing line-based patches AND any new files:

```json
{
  "patches": [
    {
      "path": "path/to/file.ts",
      "changes": [
        {
          "lines": [START_LINE, END_LINE],
          "new_content": "replacement code here",
          "description": "what this change does"
        }
      ],
      "add_at_line": 1,
      "add_content": "import { IService } from './IService';"
    }
  ],
  "new_files": [
    {
      "path": "path/to/IService.ts",
      "content": "export interface IService {\n  methodName(): void;\n}",
      "purpose": "Interface extracted from Service class to break cycle"
    }
  ],
  "reasoning": "Brief explanation of the refactoring approach"
}
```

RULES:
1. Use EXACT line numbers from the file snippets above
2. "lines": [START, END] means replace lines START through END (inclusive)
3. For insertions at a specific line, use "add_at_line" and "add_content"
4. ALWAYS include replacement code in "new_content" - do NOT leave it empty unless deleting a single import line
5. Sort multiple changes by line number for clarity
6. Preserve indentation in new_content
7. NEVER delete multiple lines without replacement - refactoring should REPLACE code, not delete it
8. For interface extraction: create a new_files entry with the interface, then modify existing files to import and use it

COMMON PATTERNS:
- Move an import from direct to lazy: change lines with the import
- Extract interface: CREATE a new interface file in new_files, ADD import at top, CHANGE class to implement interface
- Inject dependency: modify constructor lines and add parameter
- Dependency inversion: create interface file, make concrete class implement it, depend on interface instead

Example for INTERFACE EXTRACTION (recommended for breaking cycles):
```json
{
  "patches": [{
    "path": "src/service.ts",
    "changes": [{
      "lines": [1, 1],
      "new_content": "import { IDependency } from './IDependency';",
      "description": "Import the new interface instead of concrete class"
    }, {
      "lines": [5, 5],
      "new_content": "  private dep: IDependency;",
      "description": "Use interface type instead of concrete"
    }]
  }],
  "new_files": [{
    "path": "src/IDependency.ts",
    "content": "export interface IDependency {\n  doThing(data: string): void;\n}",
    "purpose": "Interface extracted to break cycle between Service and Dependency"
  }],
  "reasoning": "Extracted interface IDependency to break direct dependency cycle"
}
```

Example for replacing a direct import with a lazy one:
```json
{
  "patches": [{
    "path": "src/service.ts",
    "changes": [{
      "lines": [3, 3],
      "new_content": "// Import moved to dynamic import below",
      "description": "Comment out direct import (or delete single line)"
    }, {
      "lines": [25, 27],
      "new_content": "    const dep = await import('./dependency');\n    return dep.doThing(this.data);",
      "description": "Use dynamic import inside method"
    }]
  }],
  "reasoning": "Replaced static import with dynamic import to break initialization-time dependency"
}
```
